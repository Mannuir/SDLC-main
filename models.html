<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="/CSS/style.css">
    <title>SDLC Models</title>
</head>
<body>
    <h2>Tarkvara arendusmudelid</h2>

<button class="accordion">Koskmudel</button>
<div class="panel">
    
    <p> Koskmudel ehk tuntud ka kui klassikaline ehk jadamudel
        (Waterfall model, classic life cycle)</p>
        <b>Kirjeldas Winston W. Royce aastal 1970</b>
        
      <ul>
          <li> Jadamisi kulgevat protsessi kirjeldav mudel,
            tugineb tavalises tootearenduses kasutusel
            olnud protsessimudelile (inseneriteadus).Ühe etapi töö 
            tehakse korraga ära ja
            liigutakse uude etappi.</li>

            <img src="images/KOSK.jpeg" alt="Waterfall" width="350px"/>
          <li>Koskmudel on sobilik suurtele süsteemidele, mida arendatakse mitmes erinevas kohas korraga. 
              Sel juhul lubab eelnev korralik planeerimine töid paremini koordineerida</li>
   
        
    <li>Põhiidee kohaselt jagatakse tegevused nii, et iga tegevus toimub jadamisi eraldi etapina. </li> 
   <p><b>Royce jagas protsessi järgmisteks põhietappideks:</b>   </p> 
        <p> 1. Nõuete määratlemine.</p>
        <p>2. Süsteemi ja tarkvara kavandamine.</p>
        <p> 3. Teostus ja moodulite testimine.</p>
        <p> 4. Integratsioon ja süsteemi testimine. </p>
        <p> 5.. Kasutamine ja hooldus</p>
           
      <p> Iga faasi tulemiks on üks või mitu dokumenti, mis kinnitatakse. 
          Järgmine faas ei tohiks alata enne, kui eelmine on lõpetatud. 
          Faasidel on teatav ülekate ja info edastamine ühest teise. 
     </p>
       
        
       
  
  

</div>

<button class="accordion">V-mudel</button>
<div class="panel">
  <p>
   </p>
    

    <p>V-mudel, mis on koskmudeli alaliik, tekkis tõenäoliselt 1960.aastatel, 
      kuigi otsest viidet algallikale ei ole. V-mudeli põhirõhk on tarkvara 
      kirjutamisele ja testimisele võrdse kaalu omistamine. Antud mudelit peetakse
      tüüpilise koskmudeli laienduseks. Seal kasutatakse koskmudelis välja toodud 
      faaside vahel samu seoseid, kuid n-ö lineaarse langemise asemel liigub V-mudel
      esmalt diagonaalselt alla ning võtab pärast tarkvara kirjutamise etappi taas suuna 
      üles (moodustub v-tähe kuju).</p>

      <img src="images/V-MUDEL.png" alt="" width="250px">

    <p>Mudeli kuju iseloomustab erinevate etappide vahelisi seoseid.
      Mudelis soovitatakse dokumenteerida ka testimine. Iga testi jaoks tuleks 
      koostada rakendusplaan juba mõnes varasemas etapis ehk mitte oodata arenduse 
      lõpule jõudmist, et see siis testijatele üle anda.</p>

      <p>Võrreldes agiilse tarkvaraarenduse metoodikaga, saab V-mudeli tööversioon 
      valmis oluliselt aeglasemalt. Tegemist on üsna jäiga ja vähem paindliku 
      arendusmudeliga, millele eelistatakse pigem agiilset metoodikat.</p>

        

</div>

<button class="accordion">Inkrementaale ja iteratiivne arendusmudel</button>
<div class="panel">
  <p>Kuigi paljud peavad iteratiivset ja järkjärgulist arendust kaasaegseks 
    praktikaks, pärineb selle rakendamine juba 1950. aastate keskpaigast.</p>
    
    <p>Iga järgneva kümnendi silmapaistvad tarkvarainseneri mõtteliidrid toetasid 
    IID tavasid ja paljud suured projektid kasutasid neid edukalt. Need tavad 
    võisid oma üksikasjade poolest erineda, kuid kõigil oli ühine teema – vältida 
    ühekäigulist järjestikust, dokumendipõhist ja piiratud sammuga lähenemist.</p>

   <p>Ian Sommerville järgi on iteratiivne arendusmudel pigem üldine nimetus mitmele 
    nn hübriidmudelile (sh inkrementaal- ja spiraalmudel). Sõna "iteratiivne" rõhutab, 
    et tegevused selles mudelis korduvad.</p> 
  
  
  <ul>
   <li><b>Inkrementaalne arendus</b> on etapiviisiline ja ajagraafikut järgiv strateegia, 
    kus süsteemi osi arendatakse nii erinevatel aegadel kui erineva kiirusega. Konkreetse 
    osa valmides integreeritakse see süsteemiga. Selle suureks eeliseks on tõik, et arendajad 
    ja tulevased süsteemi kasutajad saavad varajastest iteratsioonidest õppida ning vajalikku 
    tagasisidet veel siis, kui võimalik teha muudatusi (näiteks muuta süsteemi arhitektuuri 
    kogu koodi ümber kirjutamata).
   <p>Alternatiivne strateegia oleks kodeerida kõik süsteemi osad ja siis kogu kood ühekorraga 
    integreerida.</p> 
    </li> 

    <img src="images/inkrementaalne.jpeg" alt="" width="250px">

    <li><b>Iteratiivne arendus</b> on n-ö muutmisstrateegia, kus nähakse ette olemasolevate 
      süsteemi osade ümbertegemine ja parandamine.
      <p>Alternatiivne strateegia oleks planeerida tegevused selliselt, et kõik tehtaks õigesti 
      esimesel katsel.</p>
       </li> 
  </ul>
<ul>
  <b>Inkrementaalse arenduse eelised:</b>

  <li>Aitab kokku hoida kulusid, mis võivad tekkida kasutaja nõuete muutmise tõttu. 
    Võrreldes koskmudeliga väheneb ka uuesti tehtava analüüsi ja dokumentatsiooni hulk.</li>

    <li>Kergem ja kiirem tagasiside kliendilt, kes saab anda kommentaare juba valminud osadele.</li>

    <li>Tarkvara võib jõuda kliendini kiiremini ja varem kui nt koskmudeliga.</li>
  </ul>

  <ul>
    <b>Inkrementaalse arendused probleemid:</b> 

   <li>Progress ei ole hästi jälgitav - haldurid vajavad progressi mõõtmiseks pidevalt materjale.
    Kiire arenduse korral ei ole tasuv tekitada dokumente iga pisikese versioonimuudatuse jaoks.</li>

    <li>Süsteemi struktuur kipub uute osade lisandumisel halvenema - pidev muutmine rikub süsteemi
    struktuuri. Halb struktuur muudab tarkvara hilisema muutmise keerulisemaks ja kulukamaks.</li>
    
    
  </ul>


</div>

<button class="accordion">Prototüüpimine</button>
<div class="panel">

  <p>Prototüüp on süsteemi algne versioon, mida kasutatakse disainivõimaluste katsetamiseks ning ideede demonstreerimiseks. </p>
<p>John Crinnion kirjeldas oma 1992. aastal avaldatud raamatus „Evolutionary Systems Development“ Systemscrafti prototüübi metoodikana, mida tuleks muuta ja kohandada, et see sobiks konkreetse keskkonnaga, milles seda rakendati. </p>
<p>Prototüüpe saab kasutada erinevates arenduse faasides. Näiteks nõuete analüüsietapil nende leidmiseks ja valideerimiseks; disainietapil valikuvõimaluste uurimiseks ning kasutajaliidese kavandamiseks. </p>
<p>Kasu prototüüpimisest: parem süsteemi kasutusmugavus, täpsem ühildumine kasutaja tegelike vajadustega; parem kvaliteet ja hooldatavus ning väiksem vaev arendamisel. </p>
<img src="images/PROTO.jpeg" alt="" width="250px">
<p>Joonis 1-4 Prototüübi loomise protsess</p>
<ul> 
<b>Prototüüpimise etapid on järgmised: </b>
<li> Nõuete kogumine. Tehakse üldistatult, samas fikseerides teemasid, mida soovitakse hiljem täpsustada. </li>
<li> Kiire kavandamine. Keskendutakse nähtavale osale (sisend, väljund, vormid jms), mille  tulemuseks on prototüüp. Klient saab selle alusel oma soove täpsustada. </li>
<li> Järgneb iteratsioon prototüübi parandamiseks, kuni see vastab kasutaja nõudmistele. </li>
</ul>
<p>Prototüübi arendamisel on oluline, et see saaks loodud kiiresti, kasutades selleks abivahendeid (kiire prototüüpimise keeled ja tööriistad). Prototüüp ei pea sisaldama kogu funktsionaalsust - peab keskenduma sellele, millest ei ole hästi aru saadud; prototüübis ei pea olema vigade kontrolli ning see on suunatud funktsionaalsetele nõuetele (mitte näiteks turvalisuse probleemidele). </p>
<p>Prototüüpimist võib teha erineval põhimõttel - näiteks <b>ühekordne prototüüpimine</b> (Throw away prototyping), <b>evolutsiooniline prototüüpimine</b> (Evolutionary prototyping), <b>lisanduv prototüüpimine</b> (Incremental prototyping). </p>
<b>Ühekordse prototüüpimise põhimõtted:  </b>
<p>Sellised prototüübid tuleb peale loomist likvideerida, sest nad pole tegelikule süsteemile heaks baasiks - näiteks ei pruugi nende alusel täita mittefunktsionaalseid nõudeid, prototüübi struktuur ei sobi edasiseks arenduseks ega vasta ka muudele kvaliteedinõuetele. </p>

  
</div>
<button class="accordion">Spiraalmudel</button>
<div class="panel">
  <p> Spiraalmudelit kirjeldas esimest korda Barry Boehm oma 1986. a artiklis. </p>
  <p> Spiraalmudel on üks iteratiivseid arendusmudeleid. Protsessi kulgemist kujutab spiraal. Esimene kordus võib olla näiteks seotud süsteemi teostatavuse uurimisega, teine nõudmiste kirjeldamisega, järgmine kavandamisega jne. Mitu kordust on enamasti seotud tarkvara realiseerimisega, kus selle ehitamine toimub inkrementaalselt. </p>
  <p> Spiraali korduseid ei tohi võrdsustada tavapäraste arendusprotsessi faasidega. Iga kordus on jaotatud 3 kuni 6 sektorisse (erinevad autorid jagavad erinevalt). Iga kordus algab lähima eesmärgi kavandamise ja riskide hindamisega ning lõppeb n-ö kliendiga - ehk eesmärk peab saama täidetud ja kontrollitud. Sektorite töömahukus ei pruugi olla ühesugune. </p>
  <ul> <b>Boehm'i järgi on sektoreid neli: </b> </ul>
  
  <p> 1. Eesmärkide seadmine (objective setting) - määratakse korduse eesmärgid, piirangud protsessis, tulemused, juhtimisplaan, võimalikud riskid ning lähtudes riskidest ka alternatiivsed strateegiad. </p>
  <p> 2. Riskide hindamine ja maandamine (risk assessment and reduction) - iga leitud riski jaoks tehakse analüüs ja võetakse nende maandamiseks midagi ette (nt risk, et nõudmised pole adekvaatsed: tehakse prototüüp). </p>
  <p> 3. Arendus ja valideerimine (Development and validation) - valitakse arendusmudel, mis lähtub hinnatud riskidest (mudel peab olema selline, mis aitab riske vähendada nt kui kasutajaliides on suurim risk, siis võib aidata prototüüpide tegemine). </p><p> 4. Planeerimine (Planning) - projekt vaadatakse üle ja tehakse otsus, kas jätkata järgmisel kordusel. Kui otsustatakse jätkata, siis tehakse plaan järgmise faasi jaoks. </p>
  </ul>
  <img src="images/SPIRAALmudel Boehm 1988.png" alt="" width="250px">
  <p>Joonisel 3 on kujutatud üks näide spiraalmudelist. Tegelik arendusprotsess võib varieeruda nii iteratsioonide arvu kui ka tegevuste paigutuse osas. </p>
  <p>Selle mudeli kõige olulisem erinevus teistest on riskidega arvestamine. Risk ehk võimalus, et midagi saab untsu minna. Riskide realiseerumise tõttu ületatakse tähtajad ja maksumus, seepärast peab riskidega arvestama ning võtma midagi ette nende maandamiseks. </p>
  
</div>
<button class="accordion">Agiilse tarkvaraarenduse põhimõtted</button>
<div class="panel">
  <p>Agiilsete arendusmeetodite jaoks sobib kasutada inkrementaaset mudelit. Agiilse tarkvaraarenduse levimise algus läheb 2001 aastasse, kui senise üliplaanipärase arenduse vastased kirjutasid alla "The Agile Manifesto"-le, mille kõige olulisemates punktides rõhutakse inimesele ja inimeste vahelisele suhtlemisele: </p>
<ul>
<li>Inimesed ja suhtlemine on tähtsamad kui protsessid ja tööriistad. </li>
<li>Töötav tarkvara on tähtsam kui dokumentatsioon. </li>
<li>Koostöö kliendiga on tähtsam kui läbirääkimised lepingu üle. </li>
<li>Muudatussoovidele vastutulek on tähtsam kui plaani järgmine. </li>
</ul>
<p>Enam arvestatakse tagasiside (koormustestimine, kasutajate arvamus jm) käigus saadud infoga kui loodetakse hoolika etteplaneerimise tehnikale. Põhitähelepanu on inimestel  (sh kasutajatel) ja pideval testimisel. Öeldakse, et agiilmeetoditega saavutatakse sama raha eest parem tulemus, kuigi võime tarkvara funktsioonide valmimise aega on keerulisem ette planeerida. </p>
<p>Tuntumad ja levinumad agiilsed arendusmeetodid on ekstreemprogrammeerimine (XP), Scrum, Feature Driven Development (FDD), Open Unified Process (OpenUP) jt.</p>


</div>

<script>
    var acc = document.getElementsByClassName("accordion");
var i;

for (i = 0; i < acc.length; i++) {
  acc[i].addEventListener("click", function() {
    this.classList.toggle("active");
    var panel = this.nextElementSibling;
    if (panel.style.display === "block") {
      panel.style.display = "none";
    } else {
      panel.style.display = "block";
    }
  });
}
</script>

</body>
</html>